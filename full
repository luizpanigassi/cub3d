header:

#ifndef CUB3D_H
# define CUB3D_H

// LIBS
# include "libft.h"
# include <stdio.h>
# include <fcntl.h>
# include <string.h>
# include <unistd.h>
# include <stdlib.h>
# include "../mlx/mlx.h"
# include <math.h>

// CHARS
# define MAP_CHARS " 01NSEWD"
# define PLAYER_CHARS "NSEW"

// KEYS
# define ESC_KEY 65307
# define W_KEY 119
# define A_KEY 97
# define S_KEY 115
# define D_KEY 100
# define E_KEY 101
# define F_KEY 102
# define LEFT_KEY 65361
# define RIGHT_KEY 65363

// CONFIG
# define MOVE_SPEED 0.03
# define ROTATION_SPEED 0.03
# define COLLISION_MARGIN 0.1
# define NUM_RAYS 1200
# define MAX_DOORS 128

//WINDOW SIZE
# define W 1200
# define H 800
# define TILE_SIZE 40
# define MINIMAP_MAX_W 300
# define MINIMAP_MAX_H 300

//FIREBALLS
# define MAX_FIREBALLS 6
# define FIREBALL_FRAMES 4
# define FIREBALL_SPEED 0.2
# define FIREBALL_ANIM_SPEED 0.5

typedef struct s_fireball_screen_params {
	double	rel_x;
	double	rel_y;
	double	inv_det;
	double	transform_x;
	double	transform_y;
	int		screen_x;
	int		sprite_height;
	int		sprite_width;
	int		draw_start_x;
	int		draw_end_x;
	int		draw_start_y;
	int		draw_end_y;
}	t_fireball_screen_params;

typedef struct s_minimap_tile {
	int	x;
	int	y;
	int	tile_size;
}	t_minimap_tile;

typedef struct s_player_draw {
	int	center_x;
	int	center_y;
	int	half;
	int	y;
	int	x;
	int	px;
	int	py;
	int	offset;
}	t_player_draw;

typedef struct s_vision_line {
	int	line_length;
	int	start_x;
	int	start_y;
	int	end_x;
	int	end_y;
}	t_vision_line;

typedef struct s_fireball
{
	double	x;
	double	y;
	double	dir_x;
	double	dir_y;
	int		active;
	int		distance;
	int		frame;
	int		frame_count;
}	t_fireball;

typedef struct s_line_state {
	int	dx;
	int	dy;
	int	sx;
	int	sy;
	int	err;
	int	e2;
	int	x;
	int	y;
}	t_line_state;

typedef struct s_door {
	int	x;
	int	y;
	int	is_open;
}	t_door;

typedef struct s_line {
	int	start_x;
	int	start_y;
	int	end_x;
	int	end_y;
	int	color;
}	t_line;

typedef struct s_orientation {
	double	dir_x;
	double	dir_y;
	double	plane_x;
	double	plane_y;
}	t_orientation;

typedef struct s_data
{
	char	*north;
	char	*south;
	char	*east;
	char	*west;
	char	**map;
	char	player_direction;
	int		floor;
	int		ceiling;
	int		map_width;
	int		map_height;
	int		player_x;
	int		player_y;
	t_door	doors[MAX_DOORS];
	int		door_count;
}	t_data;

typedef struct s_keys
{
	int	w;
	int	a;
	int	s;
	int	d;
	int	left;
	int	right;
	int	esc;
}	t_keys;

typedef struct s_img {
	void	*img;
	char	*addr;
	int		bpp;
	int		line_len;
	int		endian;
	int		w;
	int		h;
}	t_img;

typedef struct mlx_data
{
	void		*mlx;
	void		*win;
	void		*img;
	int			bpp;
	int			line_size;
	int			endian;
	char		*img_addr;
	t_data		*data;
	t_keys		*keys;
	t_img		*textures[5];
	double		pos_x;
	double		pos_y;
	double		dir_x;
	double		dir_y;
	double		plane_x;
	double		plane_y;
	t_fireball	fireballs[MAX_FIREBALLS];
	t_img		*fire_tex[FIREBALL_FRAMES];
}	t_mlx_data;

typedef struct s_parse_ctx
{
	t_data	*data;
	t_list	**map_lines;
	int		*max_width;
	int		*map_started;
}	t_parse_ctx;

typedef struct s_game
{
	t_data		*data;
	t_mlx_data	*mlx;
	t_keys		keys;
}	t_game;

typedef struct s_wall_draw_ctx {
	int		line_height;
	int		draw_end;
	int		draw_start;
	t_img	*tex;
	int		tex_x;
	int		tex_y;
	int		y;
	int		d;
	int		color;
}	t_wall_draw_ctx;

typedef struct s_ray_hit {
	double	dist;
	int		tex_id;
	double	wall_x;
	int		side;
	double	dir_x;
	double	dir_y;
}	t_ray_hit;

typedef struct s_dda_ctx {
	int		map_x;
	int		map_y;
	double	delta_x;
	double	delta_y;
	int		step_x;
	int		step_y;
	double	side_dist_x;
	double	side_dist_y;
	int		hit_wall;
	int		side;
	int		tex_id;
}	t_dda_ctx;

typedef struct s_square_draw_ctx {
	t_mlx_data	*mlx;
	int			x;
	int			y;
	int			tile_size;
	int			color;
}	t_square_draw_ctx;

// CONTROLLER
void		try_movement(t_mlx_data *mlx, double dx, double dy);
int			is_walkable(t_data *data, double x, double y);

// DOOR UTILS
t_door		*get_door(t_data *data, int x, int y);
int			is_door_open(t_data *data, int x, int y);
int			is_door_at(t_data *data, int x, int y);

// DOOR
void		toggle_door(t_game *game);
void		try_toggle_door(t_game *game);
void		register_doors(t_data *data);

// DRAW
void		draw_vision(t_mlx_data *mlx, int tile_size);
void		draw_square(t_square_draw_ctx *ctx);
void		draw_player(t_mlx_data *mlx, int tile_size);
void		draw_wall(t_mlx_data *mlx, int x, t_ray_hit hit);

// DRAWING UTILS
void		draw_pixel(t_mlx_data *mlx, int x, int y, int color);
void		draw_h_line(t_mlx_data *mlx, int y, int color);
void		draw_background(t_mlx_data *mlx, int sky, int ground);

// ERROR HANDLER
int			error_exit(char *msg, t_data *data);

// EVENTS
void		rotate_player_view(t_mlx_data *mlx, double angle);
int			close_event(t_game *game);
void		events(t_game *game);
int			mouse_move(int x, int y, t_game *game);

// FIRE UTILS
void		fireball_transform(t_mlx_data *mlx, t_fireball *fire,
				t_fireball_screen_params *params);
int			compute_fireball_screen_params(t_mlx_data *mlx, t_fireball *fire,
				t_fireball_screen_params *params);
void		init_fireballs(t_mlx_data *mlx);
void		load_fire_textures(t_mlx_data *mlx, t_data *data);

//FIRE
void		spawn_fireball(t_mlx_data *mlx);
void		update_fireballs(t_mlx_data *mlx);
void		draw_fireball_pixels(t_mlx_data *mlx,
				t_img *tex, t_fireball_screen_params *params);
void		draw_fireball(t_mlx_data *mlx, t_fireball *fire);
void		render_fireballs(t_mlx_data *mlx);

// FLOOD FILL
void		flood_fill(t_data *data, char **map, int x, int y);
char		**dup_map(t_data *data);

// INIT
void		init_window(t_mlx_data *mlx);
void		set_orientation(t_mlx_data *mlx, t_orientation o);
void		init_keys(t_keys *keys);
void		init_player(t_game *game);
void		init_textures(t_game *game);

// MAIN

// MAP VALIDATOR
int			is_invalid_tile(t_data *data, int x, int y);
void		validate_map_char_at(t_data *data, int x, int y, int *player_count);
void		validate_map_chars(t_data *data);
void		validate_map_with_flood_fill(t_data *data);

// MINIMAP
void		draw_line_on_minimap(t_mlx_data *mlx, t_line *line);
void		draw_minimap_tile(t_data *data, t_mlx_data *mlx,
				t_minimap_tile *tile_info);
int			get_minimap_tile_size(int map_width, int map_height);
void		minimap(t_data *data, t_mlx_data *mlx);
void		put_pixel_minimap(t_mlx_data *mlx, int x, int y, int color);

//MLX WINDOW
int			get_step_direction(int start, int end);
int			abs_int(int n);
void		update_line_state(t_line_state *s);
int			game_loop(t_game *game);
void		render_image(t_data *data);

// MOVEMENT
int			key_press(int keycode, t_game *game);
int			key_release(int keycode, t_game *game);
void		rotate_player(t_mlx_data *mlx);
void		calculate_movement(t_mlx_data *mlx, double *move_x, double *move_y);
void		update_player_position(t_game *game);

// PARSER CUB
void		handle_parse_error(char *line, char *trimmed,
				int line_num, t_parse_ctx *ctx);
int			handle_non_map_line_block(char *line, char *trimmed,
				int line_num, t_parse_ctx *ctx);
void		parse_lines_loop(int fd, t_data *data,
				t_list **map_lines, int *max_width);
void		check_required_elements(t_data *data);
t_data		*parse_cub_file(char *filename);

// PARSER UTILS
void		advance_line(char **line, int *line_num, int fd);
void		trim_newline_inplace(char *line);
int			process_non_map_line(char *line, int line_num, t_parse_ctx *ctx);
int			process_line(char **line, int *line_num, int fd, t_parse_ctx *ctx);
int			handle_map_line_block(char *line, t_list **map_lines,
				int *max_width, t_data *data);

// PARSER
int			parse_rgb_component(char *part, int *value);
int			parse_rgb(char **parts, int *rgb);
int			parse_color(char *line, t_data *data, char id);
int			parse_texture(char *line, t_data *data, const char *id);
int			parse_color_line(char *trimmed, t_data *data);

// RAY CASTING UTILS
int			get_tex_id(t_dda_ctx *ctx, double *dir);
void		set_hit_texture_and_wallx(t_game *game, t_ray_hit *hit,
				t_dda_ctx *ctx, double *dir);
t_ray_hit	ray_distance(t_game *game, int x);
int			apply_shade(int color, double distance);

// RAY CASTING
double		*ray_direction(t_game *game, int x);
void		perform_dda(t_game *game, t_dda_ctx *ctx);
void		init_dda_ctx(t_game *game, double *dir, t_dda_ctx *ctx);
void		draw_wall_column(t_mlx_data *mlx, int x,
				t_wall_draw_ctx *ctx, double dist);
void		render_view(t_game *game);

// TEXTURE LOADER
t_img		*load_xpm(void *mlx, char *path);

// MAP PROCESSING UTILS
void		copy_map_lines(t_data *data, t_list *map_lines, int max_width);
void		process_trimmed_line(char *trimmed, int *map_started,
				t_parse_ctx *ctx);
void		allocate_and_fill_map(t_data *data, t_list *map_lines,
				int max_width);
void		add_map_line(char *trimmed, t_list **map_lines, int *max_width);

// MAP UTILS
int			parse_texture_line(char *trimmed, t_data *data);
int			handle_non_map_line(char *trimmed,
				t_data *data, t_list **map_lines, int *max_width);
void		handle_map_line(char *trimmed, t_list **map_lines,
				int *max_width, t_data *data);

// UTILS
void		ft_free_array(char **array);
int			ft_isdigit_str(char *str);
void		free_data(t_data *data);
void		free_textures(t_mlx_data *mlx);
int			ft_strcmp(const char *s1, const char *s2);
char		*trim_and_free_line(char *line);
int			ft_isspace(int c);
void		report_texture_errors(t_game *game);
void		setup_orientation(t_mlx_data *mlx, char dir);

#endif

controller.c:

#include "cub3d.h"

int	is_walkable(t_data *data, double x, double y)
{
	int	map_x;
	int	map_y;

	map_x = (int)x;
	map_y = (int)y;
	if (map_y < 0 || map_y >= data->map_height
		|| map_x < 0 || map_x >= data->map_width)
		return (0);
	if (data->map[map_y][map_x] == '1')
		return (0);
	if (data->map[map_y][map_x] == 'D' && !is_door_open(data, map_x, map_y))
		return (0);
	return (1);
}

void	try_movement(t_mlx_data *mlx, double dx, double dy)
{
	double	new_x;
	double	new_y;

	new_x = mlx->pos_x + dx;
	new_y = mlx->pos_y + dy;
	if (is_walkable(mlx->data, new_x + COLLISION_MARGIN, mlx->pos_y)
		&& is_walkable(mlx->data, new_x - COLLISION_MARGIN, mlx->pos_y))
		mlx->pos_x = new_x;
	if (is_walkable(mlx->data, mlx->pos_x, new_y + COLLISION_MARGIN)
		&& is_walkable(mlx->data, mlx->pos_x, new_y - COLLISION_MARGIN))
		mlx->pos_y = new_y;
}

door_utils.c:

#include "cub3d.h"

t_door	*get_door(t_data *data, int x, int y)
{
	int	i;

	i = 0;
	while (i < data->door_count)
	{
		if (data->doors[i].x == x && data->doors[i].y == y)
			return (&data->doors[i]);
		i++;
	}
	return (NULL);
}

int	is_door_at(t_data *data, int x, int y)
{
	return (data->map[y][x] == 'D');
}

int	is_door_open(t_data *data, int x, int y)
{
	t_door	*door;

	door = get_door(data, x, y);
	return (door && door->is_open);
}

door.c:

#include "cub3d.h"

static int	is_player_far_from_door(t_game *game, int dx, int dy)
{
	double	px;
	double	py;
	double	margin;

	px = game->mlx->pos_x;
	py = game->mlx->pos_y;
	margin = 0.2;
	return (px > dx + margin || px < dx - margin
		|| py > dy + margin || py < dy - margin);
}

void	toggle_door(t_game *game)
{
	int		dx;
	int		dy;
	t_door	*door;

	dy = (int)(game->mlx->pos_y + game->mlx->dir_y);
	dx = (int)(game->mlx->pos_x + game->mlx->dir_x);
	if (is_door_at(game->data, dx, dy))
	{
		door = get_door(game->data, dx, dy);
		if (door)
		{
			if (door->is_open)
			{
				if (is_player_far_from_door(game, dx, dy))
				{
					door->is_open = 0;
				}
			}
			else
			{
				door->is_open = 1;
			}
		}
	}
}

void	try_toggle_door(t_game *game)
{
	int		tx;
	int		ty;
	t_door	*door;

	tx = (int)(game->mlx->pos_x + game->mlx->dir_x);
	ty = (int)(game->mlx->pos_y + game->mlx->dir_y);
	door = get_door(game->data, tx, ty);
	if (door)
		door->is_open = !door->is_open;
}

void	register_doors(t_data *data)
{
	int	y;
	int	x;

	y = 0;
	data->door_count = 0;
	while (y < data->map_height)
	{
		x = 0;
		while (x < data->map_width)
		{
			if (data->map[y][x] == 'D')
			{
				if (data->door_count < MAX_DOORS)
				{
					data->doors[data->door_count].x = x;
					data->doors[data->door_count].y = y;
					data->doors[data->door_count].is_open = 0;
					data->door_count++;
				}
			}
			x++;
		}
		y++;
	}
}

draw.c:

#include "cub3d.h"

void	draw_vision(t_mlx_data *mlx, int tile_size)
{
	t_vision_line	v;
	t_line			line;

	v.line_length = tile_size * 2;
	v.start_x = (int)(mlx->pos_x * tile_size);
	v.start_y = (int)(mlx->pos_y * tile_size);
	v.end_x = (int)(v.start_x + mlx->dir_x * v.line_length);
	v.end_y = (int)(v.start_y + mlx->dir_y * v.line_length);
	line.start_x = v.start_x;
	line.start_y = v.start_y;
	line.end_x = v.end_x;
	line.end_y = v.end_y;
	line.color = 0x00FF00;
	draw_line_on_minimap(mlx, &line);
}

void	draw_square(t_square_draw_ctx *ctx)
{
	int	dx;
	int	dy;
	int	px;
	int	py;
	int	offset;

	dy = 0;
	while (dy < ctx->tile_size)
	{
		dx = 0;
		while (dx < ctx->tile_size)
		{
			px = ctx->x + dx;
			py = ctx->y + dy;
			if (px >= 0 && px < W && py >= 0 && py < H)
			{
				offset = py * ctx->mlx->line_size + px * (ctx->mlx->bpp / 8);
				*(unsigned int *)(ctx->mlx->img_addr + offset) = ctx->color;
			}
			dx++;
		}
		dy++;
	}
}

void	draw_player(t_mlx_data *mlx, int tile_size)
{
	t_player_draw	p;

	p.center_x = (int)(mlx->pos_x * tile_size);
	p.center_y = (int)(mlx->pos_y * tile_size);
	p.half = tile_size / 4;
	p.y = -p.half;
	while (p.y < p.half)
	{
		p.x = -p.half;
		while (p.x < p.half)
		{
			p.px = p.center_x + p.x;
			p.py = p.center_y + p.y;
			if (p.px >= 0 && p.px < W && p.py >= 0 && p.py < H)
			{
				p.offset = p.py * mlx->line_size + p.px * (mlx->bpp / 8);
				*(unsigned int *)(mlx->img_addr + p.offset) = 0xFF0000;
			}
			p.x++;
		}
		p.y++;
	}
}

void	draw_wall(t_mlx_data *mlx, int x, t_ray_hit hit)
{
	t_wall_draw_ctx	ctx;

	if (hit.dist <= 0)
		hit.dist = 1.0;
	ctx.line_height = (int)(H / hit.dist);
	ctx.draw_start = -ctx.line_height / 2 + H / 2;
	ctx.draw_end = ctx.line_height / 2 + H / 2;
	if (ctx.draw_start < 0)
		ctx.draw_start = 0;
	if (ctx.draw_end >= H)
		ctx.draw_end = H - 1;
	ctx.tex = mlx->textures[hit.tex_id];
	ctx.tex_x = (int)(hit.wall_x * (double)ctx.tex->w);
	if ((hit.side == 0 && hit.dir_x > 0) || (hit.side == 1 && hit.dir_y < 0))
		ctx.tex_x = ctx.tex->w - ctx.tex_x - 1;
	ctx.y = ctx.draw_start;
	draw_wall_column(mlx, x, &ctx, hit.dist);
}

drawing_utils.c:

#include "cub3d.h"

void	draw_pixel(t_mlx_data *mlx, int x, int y, int color)
{
	int	offset;

	if (x < 0 || x >= W || y < 0 || y >= H)
		return ;
	offset = (y * mlx->line_size) + (x * (mlx->bpp / 8));
	*(int *)(mlx->img_addr + offset) = color;
}

void	draw_h_line(t_mlx_data *mlx, int y, int color)
{
	int	x;

	if (y >= H)
		return ;
	x = 0;
	while (x < W)
		draw_pixel(mlx, x++, y, color);
}

void	draw_background(t_mlx_data *mlx, int sky, int ground)
{
	int	y;

	y = 0;
	while (y < H)
	{
		if (y < H / 2)
			draw_h_line(mlx, y, sky);
		else
			draw_h_line(mlx, y, ground);
		y++;
	}
}

error_handler.c:

#include "cub3d.h"

int	error_exit(char *msg, t_data *data)
{
	if (data)
		free_data(data);
	ft_putstr_fd("Error\n", 2);
	ft_putstr_fd(msg, 2);
	ft_putstr_fd("\n", 2);
	exit(1);
}

events.c:

#include "cub3d.h"

void	rotate_player_view(t_mlx_data *mlx, double angle)
{
	double	old_dir_x;
	double	old_plane_x;

	old_plane_x = mlx->plane_x;
	old_dir_x = mlx->dir_x;
	mlx->dir_x = old_dir_x * cos(angle) - mlx->dir_y * sin(angle);
	mlx->dir_y = old_dir_x * sin(angle) + mlx->dir_y * cos(angle);
	mlx->plane_x = old_plane_x * cos(angle) - mlx->plane_y * sin(angle);
	mlx->plane_y = old_plane_x * sin(angle) + mlx->plane_y * cos(angle);
}

int	close_event(t_game *game)
{
	t_mlx_data	*mlx;

	mlx = game->mlx;
	if (mlx->img)
	{
		mlx_destroy_image(mlx->mlx, mlx->img);
		mlx->img = NULL;
	}
	free_textures(mlx);
	if (mlx->win)
	{
		mlx_destroy_window(mlx->mlx, mlx->win);
		mlx->win = NULL;
	}
	if (mlx->mlx)
	{
		mlx_destroy_display(mlx->mlx);
		free(mlx->mlx);
		mlx->mlx = NULL;
	}
	free(mlx);
	free_data(game->data);
	free(game);
	exit(0);
	return (0);
}

void	events(t_game *game)
{
	mlx_hook(game->mlx->win, 2, 1L << 0, key_press, game);
	mlx_hook(game->mlx->win, 3, 1L << 1, key_release, game);
	mlx_hook(game->mlx->win, 17, 0, close_event, game);
	mlx_hook(game->mlx->win, 6, 1L << 6, mouse_move, game);
}

int	mouse_move(int x, int y, t_game *game)
{
	static int	last_x = -1;
	double		angle;
	int			dx;

	if (!game || !game->mlx)
		return (0);
	if (last_x == -1)
	{
		last_x = x;
		return (0);
	}
	dx = x - last_x;
	if (dx != 0)
	{
		angle = dx * 0.01;
		if (angle > 0.1)
			angle = 0.1;
		if (angle < -0.1)
			angle = -0.1;
		rotate_player_view(game->mlx, angle);
	}
	last_x = x;
	return (y);
}

fire_utils.c:

#include "cub3d.h"

void	fireball_transform(t_mlx_data *mlx, t_fireball *fire,
	t_fireball_screen_params *params)
{
	params->rel_x = fire->x - mlx->pos_x;
	params->rel_y = fire->y - mlx->pos_y;
	params->inv_det = 1.0 / (mlx->plane_x
			* mlx->dir_y - mlx->dir_x * mlx->plane_y);
	params->transform_x = params->inv_det
		* (mlx->dir_y * params->rel_x - mlx->dir_x * params->rel_y);
	params->transform_y = params->inv_det
		* (-mlx->plane_y * params->rel_x + mlx->plane_x * params->rel_y);
}

int	compute_fireball_screen_params(t_mlx_data *mlx, t_fireball *fire,
									t_fireball_screen_params *params)
{
	fireball_transform(mlx, fire, params);
	if (params->transform_y <= 0)
		return (0);
	params->screen_x = (int)((W / 2)
			* (1 + params->transform_x / params->transform_y));
	params->sprite_height = abs((int)(H / params->transform_y));
	params->sprite_width = params->sprite_height;
	params->draw_start_x = params->screen_x - params->sprite_width / 2;
	params->draw_end_x = params->screen_x + params->sprite_width / 2;
	params->draw_start_y = (H / 2) - params->sprite_height / 2;
	params->draw_end_y = (H / 2) + params->sprite_height / 2;
	if (params->draw_start_x < 0)
		params->draw_start_x = 0;
	if (params->draw_end_x >= W)
		params->draw_end_x = W - 1;
	if (params->draw_start_y < 0)
		params->draw_start_y = 0;
	if (params->draw_end_y >= H)
		params->draw_end_y = H - 1;
	return (1);
}

void	init_fireballs(t_mlx_data *mlx)
{
	int	i;

	i = 0;
	while (i < MAX_FIREBALLS)
	{
		mlx->fireballs[i].active = 0;
		mlx->fireballs[i].frame = 0;
		mlx->fireballs[i].frame_count = 0;
		i++;
	}
}

void	load_fire_textures(t_mlx_data *mlx, t_data *data)
{
	int		i;
	char	*paths[FIREBALL_FRAMES];

	paths[0] = "textures/fire/fire0.xpm";
	paths[1] = "textures/fire/fire1.xpm";
	paths[2] = "textures/fire/fire2.xpm";
	paths[3] = "textures/fire/fire3.xpm";
	i = 0;
	while (i < FIREBALL_FRAMES)
	{
		mlx->fire_tex[i] = load_xpm(mlx->mlx, paths[i]);
		if (!mlx->fire_tex[i])
			error_exit("Fire texture loading failed", data);
		i++;
	}
}

fire.c:

#include "cub3d.h"

void	spawn_fireball(t_mlx_data *mlx)
{
	int	i;

	i = 0;
	while (i < MAX_FIREBALLS)
	{
		if (!mlx->fireballs[i].active)
		{
			mlx->fireballs[i].x = mlx->pos_x + mlx->dir_x * 1.5;
			mlx->fireballs[i].y = mlx->pos_y + mlx->dir_y * 1.5;
			mlx->fireballs[i].dir_x = mlx->dir_x;
			mlx->fireballs[i].dir_y = mlx->dir_y;
			mlx->fireballs[i].active = 1;
			mlx->fireballs[i].distance = 0;
			mlx->fireballs[i].frame = 0;
			mlx->fireballs[i].frame_count = 0;
			return ;
		}
		i++;
	}
}

void	update_fireballs(t_mlx_data *mlx)
{
	int	i;

	i = 0;
	while (i < MAX_FIREBALLS)
	{
		if (mlx->fireballs[i].active)
		{
			mlx->fireballs[i].x += mlx->fireballs[i].dir_x * FIREBALL_SPEED;
			mlx->fireballs[i].y += mlx->fireballs[i].dir_y * FIREBALL_SPEED;
			mlx->fireballs[i].distance++;
			mlx->fireballs[i].frame_count++;
			if (mlx->fireballs[i].frame_count >= FIREBALL_ANIM_SPEED)
			{
				mlx->fireballs[i].frame_count = 0;
				mlx->fireballs[i].frame = (mlx->fireballs[i].frame + 1)
					% FIREBALL_FRAMES;
			}
			if (!is_walkable(mlx->data, mlx->fireballs[i].x,
					mlx->fireballs[i].y) || mlx->fireballs[i].distance > 80)
				mlx->fireballs[i].active = 0;
		}
		i++;
	}
}

void	draw_fireball_pixels(t_mlx_data *mlx,
	t_img *tex, t_fireball_screen_params *params)
{
	int	y;
	int	x;
	int	tex_y;
	int	tex_x;
	int	color;

	y = params->draw_start_y;
	while (y < params->draw_end_y)
	{
		tex_y = ((y - params->draw_start_y) * tex->h) / params->sprite_height;
		x = params->draw_start_x;
		while (x < params->draw_end_x)
		{
			tex_x = ((x - params->draw_start_x)
					* tex->w) / params->sprite_width;
			color = *(int *)(tex->addr + (tex_y
						* tex->line_len + tex_x * (tex->bpp / 8)));
			if (color != 0x00FFFFFF)
				draw_pixel(mlx, x, y, color);
			x++;
		}
		y++;
	}
}

void	draw_fireball(t_mlx_data *mlx, t_fireball *fire)
{
	t_img						*tex;
	t_fireball_screen_params	params;

	if (!fire->active || !mlx->fire_tex[fire->frame])
		return ;
	if (!compute_fireball_screen_params(mlx, fire, &params))
		return ;
	tex = mlx->fire_tex[fire->frame];
	draw_fireball_pixels(mlx, tex, &params);
}

void	render_fireballs(t_mlx_data *mlx)
{
	int	i;

	i = 0;
	while (i < MAX_FIREBALLS)
	{
		if (mlx->fireballs[i].active)
			draw_fireball(mlx, &mlx->fireballs[i]);
		i++;
	}
}

flood_fill.c:

#include "cub3d.h"

void	flood_fill(t_data *data, char **map, int x, int y)
{
	if (y < 0 || y >= data->map_height
		|| x < 0 || x >= (int)ft_strlen(map[y]))
	{
		fprintf(stderr, "Flood fill escaped at (%d, %d)\n", x, y);
		error_exit("Map leak: flood escaped the map!", data);
	}
	if (map[y][x] == '1' || map[y][x] == 'F')
		return ;
	if (map[y][x] == ' ')
		error_exit("Map leak: flood hit open space!", data);
	if (!ft_strchr("0NSEW", map[y][x]))
		return ;
	map[y][x] = 'F';
	flood_fill(data, map, x + 1, y);
	flood_fill(data, map, x - 1, y);
	flood_fill(data, map, x, y + 1);
	flood_fill(data, map, x, y - 1);
}

char	**dup_map(t_data *data)
{
	char	**copy;
	int		i;

	copy = ft_calloc(data->map_height + 1, sizeof(char *));
	i = 0;
	if (!copy)
		error_exit("Memory failed during flood fill", data);
	while (i < data->map_height)
	{
		copy[i] = ft_strdup(data->map[i]);
		i++;
	}
	return (copy);
}

init.c:

#include "cub3d.h"

void	init_window(t_mlx_data *mlx)
{
	mlx->mlx = mlx_init();
	mlx->win = mlx_new_window(mlx->mlx, W, H, "Cub3d");
	mlx->img = mlx_new_image(mlx->mlx, W, H);
	mlx->img_addr = mlx_get_data_addr(mlx->img,
			&mlx->bpp, &mlx->line_size, &mlx->endian);
}

void	set_orientation(t_mlx_data *mlx, t_orientation o)
{
	mlx->dir_x = o.dir_x;
	mlx->dir_y = o.dir_y;
	mlx->plane_x = o.plane_x;
	mlx->plane_y = o.plane_y;
}

void	init_keys(t_keys *keys)
{
	keys->w = 0;
	keys->a = 0;
	keys->s = 0;
	keys->d = 0;
	keys->left = 0;
	keys->right = 0;
	keys->esc = 0;
}

void	init_player(t_game *game)
{
	init_keys(&game->keys);
	game->mlx->pos_x = game->data->player_x + 0.5;
	game->mlx->pos_y = game->data->player_y + 0.5;
	setup_orientation(game->mlx, game->data->player_direction);
}

void	init_textures(t_game *game)
{
	t_mlx_data	*mlx;

	mlx = game->mlx;
	mlx->textures[0] = load_xpm(mlx->mlx, game->data->north);
	mlx->textures[1] = load_xpm(mlx->mlx, game->data->south);
	mlx->textures[2] = load_xpm(mlx->mlx, game->data->east);
	mlx->textures[3] = load_xpm(mlx->mlx, game->data->west);
	mlx->textures[4] = load_xpm(mlx->mlx, "textures/door.xpm");
	load_fire_textures(mlx, game->data);
	init_fireballs(mlx);
	if (!mlx->textures[0] || !mlx->textures[1]
		|| !mlx->textures[2] || !mlx->textures[3] || !mlx->textures[4])
	{
		report_texture_errors(game);
	}
}

main.c:

#include "cub3d.h"

int	main(int argc, char **argv)
{
	char	*ext;
	t_data	*data;

	if (argc != 2)
		error_exit("Usage: ./cub3D <map.cub>", NULL);
	ext = ft_strrchr(argv[1], '.');
	if (!ext || ft_strcmp(ext, ".cub"))
		error_exit("Invalid file extension", NULL);
	data = parse_cub_file(argv[1]);
	printf("Map parsed successfully!\n");
	render_image(data);
	free_data(data);
	return (0);
}

map_validator.c:

#include "cub3d.h"

int	is_invalid_tile(t_data *data, int x, int y)
{
	if (y < 0 || y >= data->map_height)
		return (1);
	if (x < 0 || x >= (int)ft_strlen(data->map[y]))
		return (1);
	if (data->map[y][x] == ' ')
		return (1);
	return (0);
}

void	validate_map_char_at(t_data *data, int x, int y, int *player_count)
{
	char	c;

	c = data->map[y][x];
	if (!ft_strchr(MAP_CHARS, c))
	{
		fprintf(stderr, "Invalid character '%c' at (%d, %d)\n", c, x, y);
		error_exit("Wait, your map has invalid characters!", data);
	}
	if (ft_strchr(PLAYER_CHARS, c))
	{
		(*player_count)++;
		data->player_x = x;
		data->player_y = y;
		data->player_direction = c;
	}
}

void	validate_map_chars(t_data *data)
{
	int	player_count;
	int	y;
	int	x;

	y = 0;
	player_count = 0;
	while (y < data->map_height)
	{
		x = 0;
		while (x < data->map_width)
		{
			validate_map_char_at(data, x, y, &player_count);
			x++;
		}
		y++;
	}
	if (player_count == 0)
		error_exit("Wait, there's no player in the map!", data);
	else if (player_count != 1)
		error_exit("Wait, there's too many players in the map!", data);
}

void	validate_map_with_flood_fill(t_data *data)
{
	char	**map_copy;

	map_copy = dup_map(data);
	flood_fill(data, map_copy, data->player_x, data->player_y);
	ft_free_array(map_copy);
}

minimap.c:

#include "cub3d.h"

void	draw_line_on_minimap(t_mlx_data *mlx, t_line *line)
{
	t_line_state	s;

	s.dx = line->end_x - line->start_x;
	s.dy = line->end_y - line->start_y;
	s.sx = get_step_direction(line->start_x, line->end_x);
	s.sy = get_step_direction(line->start_y, line->end_y);
	s.dx = abs_int(s.dx);
	s.dy = abs_int(s.dy);
	s.err = s.dx - s.dy;
	s.x = line->start_x;
	s.y = line->start_y;
	while (1)
	{
		put_pixel_minimap(mlx, s.x, s.y, line->color);
		if (s.x == line->end_x && s.y == line->end_y)
			break ;
		update_line_state(&s);
	}
}

void	draw_minimap_tile(t_data *data, t_mlx_data *mlx,
	t_minimap_tile *tile_info)
{
	char				tile;
	int					color;
	t_square_draw_ctx	ctx;

	tile = data->map[tile_info->y][tile_info->x];
	color = 0x000000;
	if (tile == '1')
		color = 0xFFFFFF;
	else if (tile == '0' || ft_strchr("NSEW", tile))
		color = 0x808080;
	else if (tile == 'D')
	{
		if (is_door_open(data, tile_info->x, tile_info->y))
			color = 0x00FF00;
		else
			color = 0xFF0000;
	}
	ctx.mlx = mlx;
	ctx.x = tile_info->x * tile_info->tile_size;
	ctx.y = tile_info->y * tile_info->tile_size;
	ctx.tile_size = tile_info->tile_size;
	ctx.color = color;
	draw_square(&ctx);
}

int	get_minimap_tile_size(int map_width, int map_height)
{
	int	tile_w;
	int	tile_h;
	int	tile_size;

	tile_w = MINIMAP_MAX_W / map_width;
	tile_h = MINIMAP_MAX_H / map_height;
	if (tile_w < tile_h)
		tile_size = tile_w;
	else
		tile_size = tile_h;
	if (tile_size < 1)
		tile_size = 1;
	return (tile_size);
}

void	minimap(t_data *data, t_mlx_data *mlx)
{
	int				tile_size;
	int				y;
	int				x;
	t_minimap_tile	tile_info;

	tile_size = get_minimap_tile_size(data->map_width, data->map_height);
	y = 0;
	while (y < data->map_height)
	{
		x = 0;
		while (x < data->map_width)
		{
			tile_info.x = x;
			tile_info.y = y;
			tile_info.tile_size = tile_size;
			draw_minimap_tile(data, mlx, &tile_info);
			x++;
		}
		y++;
	}
	draw_player(mlx, tile_size);
	draw_vision(mlx, tile_size);
}

void	put_pixel_minimap(t_mlx_data *mlx, int x, int y, int color)
{
	int	offset;

	if (x >= 0 && x < W && y >= 0 && y < H)
	{
		offset = y * mlx->line_size + x * (mlx->bpp / 8);
		*(unsigned int *)(mlx->img_addr + offset) = color;
	}
}

mlx_window.c:

#include "cub3d.h"

int	get_step_direction(int start, int end)
{
	if (start < end)
		return (1);
	else
		return (-1);
}

int	abs_int(int n)
{
	if (n < 0)
		return (-n);
	else
		return (n);
}

void	update_line_state(t_line_state *s)
{
	s->e2 = 2 * s->err;
	if (s->e2 > -s->dy)
	{
		s->err -= s->dy;
		s->x += s->sx;
	}
	if (s->e2 < s->dx)
	{
		s->err += s->dx;
		s->y += s->sy;
	}
}

int	game_loop(t_game *game)
{
	update_player_position(game);
	update_fireballs(game->mlx);
	ft_bzero(game->mlx->img_addr, H * game->mlx->line_size);
	draw_background(game->mlx, game->data->ceiling, game->data->floor);
	render_view(game);
	render_fireballs(game->mlx);
	minimap(game->data, game->mlx);
	mlx_put_image_to_window(game->mlx->mlx,
		game->mlx->win, game->mlx->img, 0, 0);
	return (0);
}

void	render_image(t_data *data)
{
	t_mlx_data	*mlx;
	t_game		*game;

	mlx = malloc(sizeof(t_mlx_data));
	game = malloc(sizeof(t_game));
	if (!mlx || !game)
		error_exit("Malloc failed", NULL);
	game->data = data;
	game->mlx = mlx;
	mlx->data = data;
	mlx->keys = &game->keys;
	mlx->mlx = mlx_init();
	if (!mlx->mlx)
		error_exit("MLX init failed", NULL);
	init_window(mlx);
	init_textures(game);
	init_player(game);
	events(game);
	mlx_loop_hook(mlx->mlx, game_loop, game);
	mlx_loop(mlx->mlx);
}

movement.c:

#include "cub3d.h"

int	key_press(int keycode, t_game *game)
{
	if (keycode == W_KEY)
		game->keys.w = 1;
	else if (keycode == A_KEY)
		game->keys.a = 1;
	else if (keycode == S_KEY)
		game->keys.s = 1;
	else if (keycode == D_KEY)
		game->keys.d = 1;
	else if (keycode == LEFT_KEY)
		game->keys.left = 1;
	else if (keycode == RIGHT_KEY)
		game->keys.right = 1;
	else if (keycode == E_KEY)
		toggle_door(game);
	else if (keycode == ESC_KEY)
		close_event(game);
	else if (keycode == F_KEY)
		spawn_fireball(game->mlx);
	return (0);
}

int	key_release(int keycode, t_game *game)
{
	if (keycode == W_KEY)
		game->keys.w = 0;
	else if (keycode == A_KEY)
		game->keys.a = 0;
	else if (keycode == S_KEY)
		game->keys.s = 0;
	else if (keycode == D_KEY)
		game->keys.d = 0;
	else if (keycode == LEFT_KEY)
		game->keys.left = 0;
	else if (keycode == RIGHT_KEY)
		game->keys.right = 0;
	else if (keycode == ESC_KEY)
		game->keys.esc = 0;
	return (0);
}

void	rotate_player(t_mlx_data *mlx)
{
	double	old_dir_x;
	double	old_plane_x;
	double	angle;

	old_dir_x = mlx->dir_x;
	old_plane_x = mlx->plane_x;
	angle = 0;
	if (mlx->keys->left)
		angle -= ROTATION_SPEED;
	if (mlx->keys->right)
		angle += ROTATION_SPEED;
	if (angle != 0)
	{
		mlx->dir_x = mlx->dir_x * cos(angle) - mlx->dir_y * sin(angle);
		mlx->dir_y = old_dir_x * sin(angle) + mlx->dir_y * cos(angle);
		mlx->plane_x = mlx->plane_x * cos(angle) - mlx->plane_y * sin(angle);
		mlx->plane_y = old_plane_x * sin(angle) + mlx->plane_y * cos(angle);
	}
}

void	calculate_movement(t_mlx_data *mlx, double *move_x, double *move_y)
{
	*move_x = 0;
	*move_y = 0;
	if (mlx->keys->w)
	{
		*move_x += mlx->dir_x * MOVE_SPEED;
		*move_y += mlx->dir_y * MOVE_SPEED;
	}
	if (mlx->keys->s)
	{
		*move_x -= mlx->dir_x * MOVE_SPEED;
		*move_y -= mlx->dir_y * MOVE_SPEED;
	}
	if (mlx->keys->d)
	{
		*move_x += mlx->plane_x * MOVE_SPEED;
		*move_y += mlx->plane_y * MOVE_SPEED;
	}
	if (mlx->keys->a)
	{
		*move_x -= mlx->plane_x * MOVE_SPEED;
		*move_y -= mlx->plane_y * MOVE_SPEED;
	}
}

void	update_player_position(t_game *game)
{
	double	move_x;
	double	move_y;

	calculate_movement(game->mlx, &move_x, &move_y);
	try_movement(game->mlx, move_x, move_y);
	rotate_player(game->mlx);
}

parser_cub.c:

#include "cub3d.h"

void	handle_parse_error(char *line, char *trimmed,
	int line_num, t_parse_ctx *ctx)
{
	fprintf(stderr,
		"Error\nUnrecognized line at %d: \"%s\"\n", line_num, line);
	free(trimmed);
	free(line);
	error_exit("Parsing failed due to unrecognized line.", ctx->data);
}

int	handle_non_map_line_block(char *line, char *trimmed,
					int line_num, t_parse_ctx *ctx)
{
	int	res;

	if (!trimmed)
	{
		free(line);
		return (0);
	}
	if (trimmed[0] == '\0')
	{
		free(trimmed);
		free(line);
		return (0);
	}
	res = handle_non_map_line(trimmed, ctx->data,
			ctx->map_lines, ctx->max_width);
	if (res == 1)
		free(line);
	else if (res == 2)
	{
		*(ctx->map_started) = 1;
		handle_map_line(line, ctx->map_lines, ctx->max_width, ctx->data);
	}
	else
		handle_parse_error(line, trimmed, line_num, ctx);
	return (1);
}

void	parse_lines_loop(int fd, t_data *data,
			t_list **map_lines, int *max_width)
{
	char		*line;
	int			map_started;
	int			line_num;
	t_parse_ctx	ctx;

	map_started = 0;
	line_num = 1;
	ctx.map_started = &map_started;
	ctx.data = data;
	ctx.map_lines = map_lines;
	ctx.max_width = max_width;
	line = get_next_line(fd);
	while (line)
		process_line(&line, &line_num, fd, &ctx);
}

void	check_required_elements(t_data *data)
{
	if (!data->north || !data->south || !data->east || !data->west
		|| data->floor == -1 || data->ceiling == -1)
	{
		fprintf(stderr, "Error\nMissing required map elements:\n");
		if (!data->north)
			fprintf(stderr, "- North texture (NO)\n");
		if (!data->south)
			fprintf(stderr, "- South texture (SO)\n");
		if (!data->east)
			fprintf(stderr, "- East texture (EA)\n");
		if (!data->west)
			fprintf(stderr, "- West texture (WE)\n");
		if (data->floor == -1)
			fprintf(stderr, "- Floor color (F)\n");
		if (data->ceiling == -1)
			fprintf(stderr, "- Ceiling color (C)\n");
		error_exit("There's something missing in your map!", data);
	}
}

t_data	*parse_cub_file(char *filename)
{
	int		fd;
	t_data	*data;
	t_list	*map_lines;
	int		max_width;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		error_exit("Something is wrong with the file!", NULL);
	data = ft_calloc(1, sizeof(t_data));
	if (!data)
		error_exit("Memory allocation failed!", NULL);
	data->floor = -1;
	data->ceiling = -1;
	map_lines = NULL;
	max_width = 0;
	parse_lines_loop(fd, data, &map_lines, &max_width);
	close(fd);
	check_required_elements(data);
	allocate_and_fill_map(data, map_lines, max_width);
	register_doors(data);
	ft_lstclear(&map_lines, free);
	validate_map_chars(data);
	validate_map_with_flood_fill(data);
	return (data);
}

parser_utils.c:

#include "cub3d.h"

void	advance_line(char **line, int *line_num, int fd)
{
	*line = get_next_line(fd);
	(*line_num)++;
}

void	trim_newline_inplace(char *line)
{
	char	*nl;

	nl = strchr(line, '\n');
	if (nl)
		*nl = '\0';
}

int	process_non_map_line(char *line, int line_num, t_parse_ctx *ctx)
{
	char	*trimmed;
	int		result;

	trimmed = trim_and_free_line(ft_strdup(line));
	result = handle_non_map_line_block(line, trimmed, line_num, ctx);
	return (result);
}

int	process_line(char **line, int *line_num, int fd, t_parse_ctx *ctx)
{
	trim_newline_inplace(*line);
	if (*(ctx->map_started))
	{
		if (!handle_map_line_block(*line, ctx->map_lines,
				ctx->max_width, ctx->data))
		{
			advance_line(line, line_num, fd);
			return (1);
		}
	}
	else
	{
		if (!process_non_map_line(*line, *line_num, ctx))
		{
			advance_line(line, line_num, fd);
			return (1);
		}
	}
	advance_line(line, line_num, fd);
	return (1);
}

int	handle_map_line_block(char *line, t_list **map_lines,
		int *max_width, t_data *data)
{
	char	*trimmed;

	trimmed = trim_and_free_line(ft_strdup(line));
	if (!trimmed || trimmed[0] == '\0')
	{
		free(trimmed);
		free(line);
		return (0);
	}
	handle_map_line(line, map_lines, max_width, data);
	free(trimmed);
	return (1);
}

parsers.c:

#include "cub3d.h"

int	parse_rgb_component(char *part, int *value)
{
	char	*trimmed;
	int		res;

	trimmed = ft_strtrim(part, " \t\n");
	if (!trimmed || !ft_isdigit_str(trimmed))
	{
		free(trimmed);
		return (0);
	}
	res = ft_atoi(trimmed);
	free(trimmed);
	if (res < 0 || res > 255)
		return (0);
	*value = res;
	return (1);
}

int	parse_rgb(char **parts, int *rgb)
{
	int	i;

	i = 0;
	while (i < 3)
	{
		if (!parse_rgb_component(parts[i], &rgb[i]))
			return (0);
		i++;
	}
	return (1);
}

int	parse_color(char *line, t_data *data, char id)
{
	char	**parts;
	int		rgb[3];
	int		color;

	if ((id == 'F' && data->floor != -1) || (id == 'C' && data->ceiling != -1))
		return (0);
	parts = ft_split(line, ',');
	if (!parts || !parts[0] || !parts[1] || !parts[2] || parts[3])
		return (ft_free_array(parts), 0);
	if (!parse_rgb(parts, rgb))
		return (ft_free_array(parts), 0);
	color = (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
	if (id == 'F')
		data->floor = color;
	else if (id == 'C')
		data->ceiling = color;
	ft_free_array(parts);
	return (1);
}

int	parse_texture(char *line, t_data *data, const char *id)
{
	char	*path;

	path = ft_strtrim(line + 3, " \t");
	if (!path)
		return (0);
	if (access(path, R_OK))
	{
		fprintf(stderr, "Error: Cannot access texture file: %s\n", path);
		free(path);
		return (0);
	}
	if (!ft_strcmp(id, "NO"))
		data->north = path;
	else if (!ft_strcmp(id, "SO"))
		data->south = path;
	else if (!ft_strcmp(id, "EA"))
		data->east = path;
	else if (!ft_strcmp(id, "WE"))
		data->west = path;
	else
	{
		free(path);
		return (0);
	}
	return (1);
}

int	parse_color_line(char *trimmed, t_data *data)
{
	if (trimmed[0] == 'F' && ft_isspace(trimmed[1]))
	{
		if (!parse_color(trimmed + 2, data, 'F'))
		{
			fprintf(stderr,
				"Error: Invalid floor color format: \"%s\"\n", trimmed + 2);
			error_exit("Invalid floor color!", data);
		}
		return (1);
	}
	else if (trimmed[0] == 'C' && ft_isspace(trimmed[1]))
	{
		if (!parse_color(trimmed + 2, data, 'C'))
			error_exit("Invalid ceiling color!", data);
		return (1);
	}
	return (0);
}

ray_cast_utils.c:

#include "cub3d.h"

int	get_tex_id(t_dda_ctx *ctx, double *dir)
{
	if (ctx->tex_id == 4)
		return (4);
	if (ctx->side == 0)
	{
		if (dir[0] > 0)
			return (3);
		else
			return (2);
	}
	else
	{
		if (dir[1] > 0)
			return (0);
		else
			return (1);
	}
}

void	set_hit_texture_and_wallx(t_game *game, t_ray_hit *hit,
		t_dda_ctx *ctx, double *dir)
{
	double	wall_x;

	hit->tex_id = get_tex_id(ctx, dir);
	if (ctx->side == 0)
		wall_x = game->mlx->pos_y + hit->dist * dir[1];
	else
		wall_x = game->mlx->pos_x + hit->dist * dir[0];
	hit->wall_x = wall_x - floor(wall_x);
}

t_ray_hit	ray_distance(t_game *game, int x)
{
	t_ray_hit	hit;
	double		*dir;
	t_dda_ctx	ctx;

	hit.tex_id = -1;
	dir = ray_direction(game, x);
	if (!dir)
		return ((t_ray_hit){-1, 0, 0, 0, 0, 0});
	hit.dir_x = dir[0];
	hit.dir_y = dir[1];
	init_dda_ctx(game, dir, &ctx);
	ctx.tex_id = -1;
	perform_dda(game, &ctx);
	hit.side = ctx.side;
	if (ctx.side == 0)
		hit.dist = ctx.side_dist_x - ctx.delta_x;
	else
		hit.dist = ctx.side_dist_y - ctx.delta_y;
	set_hit_texture_and_wallx(game, &hit, &ctx, dir);
	free(dir);
	return (hit);
}

int	apply_shade(int color, double distance)
{
	double	shade;
	int		r;
	int		g;
	int		b;

	if (distance < 1.0)
		distance = 1.0;
	shade = 1 / (distance * 0.15 + 1);
	if (shade > 1.0)
		shade = 1.0;
	r = ((color >> 16) & 0xFF) * shade;
	g = ((color >> 8) & 0xFF) * shade;
	b = (color & 0xFF) * shade;
	return ((r << 16) | (g << 8) | b);
}

ray_cast.c:

#include "cub3d.h"

double	*ray_direction(t_game *game, int x)
{
	double	camera_x;
	double	*ray;

	ray = malloc(sizeof(double) * 2);
	if (!ray)
		return (NULL);
	camera_x = 2 * x / (double)(W)-1;
	ray[0] = game->mlx->dir_x + game->mlx->plane_x * camera_x;
	ray[1] = game->mlx->dir_y + game->mlx->plane_y * camera_x;
	return (ray);
}

void	perform_dda(t_game *game, t_dda_ctx *ctx)
{
	ctx->hit_wall = 0;
	while (!ctx->hit_wall)
	{
		if (ctx->side_dist_x < ctx->side_dist_y)
		{
			ctx->side_dist_x += ctx->delta_x;
			ctx->map_x += ctx->step_x;
			ctx->side = 0;
		}
		else
		{
			ctx->side_dist_y += ctx->delta_y;
			ctx->map_y += ctx->step_y;
			ctx->side = 1;
		}
		if (game->data->map[ctx->map_y][ctx->map_x] == '1')
			ctx->hit_wall = 1;
		else if (game->data->map[ctx->map_y][ctx->map_x] == 'D'
			&& !is_door_open(game->data, ctx->map_x, ctx->map_y))
		{
			ctx->hit_wall = 1;
			ctx->tex_id = 4;
		}
	}
}

void	init_dda_ctx(t_game *game, double *dir, t_dda_ctx *ctx)
{
	ctx->map_x = (int)game->mlx->pos_x;
	ctx->map_y = (int)game->mlx->pos_y;
	ctx->delta_x = fabs(1.0 / dir[0]);
	ctx->delta_y = fabs(1.0 / dir[1]);
	if (dir[0] < 0)
	{
		ctx->step_x = -1;
		ctx->side_dist_x = (game->mlx->pos_x - ctx->map_x) * ctx->delta_x;
	}
	else
	{
		ctx->step_x = 1;
		ctx->side_dist_x = (ctx->map_x + 1.0 - game->mlx->pos_x) * ctx->delta_x;
	}
	if (dir[1] < 0)
	{
		ctx->step_y = -1;
		ctx->side_dist_y = (game->mlx->pos_y - ctx->map_y) * ctx->delta_y;
	}
	else
	{
		ctx->step_y = 1;
		ctx->side_dist_y = (ctx->map_y + 1.0 - game->mlx->pos_y) * ctx->delta_y;
	}
}

void	draw_wall_column(t_mlx_data *mlx, int x,
			t_wall_draw_ctx *ctx, double dist)
{
	while (ctx->y < ctx->draw_end)
	{
		ctx->d = ctx->y * 256 - H * 128 + ctx->line_height * 128;
		ctx->tex_y = (ctx->d * ctx->tex->h) / ctx->line_height / 256;
		ctx->color = *(int *)(ctx->tex->addr + (ctx->tex_y
					* ctx->tex->line_len + ctx->tex_x * (ctx->tex->bpp / 8)));
		ctx->color = apply_shade(ctx->color, dist);
		draw_pixel(mlx, x, ctx->y, ctx->color);
		ctx->y++;
	}
}

void	render_view(t_game *game)
{
	int			x;
	t_ray_hit	hit;

	x = 0;
	while (x < W)
	{
		hit = ray_distance(game, x);
		draw_wall(game->mlx, x, hit);
		x++;
	}
}

texture_loader.c:

#include "cub3d.h"

t_img	*load_xpm(void *mlx, char *path)
{
	t_img	*img;

	img = malloc(sizeof(t_img));
	if (!img)
		return (NULL);
	img->img = mlx_xpm_file_to_image(mlx, path, &img->w, &img->h);
	if (!img->img)
		error_exit("Failed to load XPM texture", NULL);
	img->addr = mlx_get_data_addr(img->img,
			&img->bpp, &img->line_len, &img->endian);
	return (img);
}

map_processing_utils.c:

#include "cub3d.h"

void	copy_map_lines(t_data *data, t_list *map_lines, int max_width)
{
	t_list	*tmp;
	int		i;

	tmp = map_lines;
	i = 0;
	while (tmp)
	{
		data->map[i] = ft_calloc(max_width + 1, sizeof(char));
		if (!data->map[i])
			error_exit("Memory allocation failed for map line!", data);
		ft_memset(data->map[i], ' ', max_width);
		ft_memcpy(data->map[i], tmp->content, ft_strlen(tmp->content));
		tmp = tmp->next;
		i++;
	}
}

void	process_trimmed_line(char *trimmed, int *map_started, t_parse_ctx *ctx)
{
	int	res;

	if (!*map_started)
	{
		res = handle_non_map_line(trimmed, ctx->data,
				ctx->map_lines, ctx->max_width);
		if (res == 2)
			*map_started = 1;
	}
	else
	{
		handle_map_line(trimmed, ctx->map_lines, ctx->max_width, ctx->data);
	}
}

void	allocate_and_fill_map(t_data *data, t_list *map_lines, int max_width)
{
	data->map_height = ft_lstsize(map_lines);
	data->map_width = max_width;
	data->map = ft_calloc(data->map_height + 1, sizeof(char *));
	if (!data->map)
		error_exit("Memory allocation failed for map!", data);
	copy_map_lines(data, map_lines, max_width);
}

void	add_map_line(char *trimmed, t_list **map_lines, int *max_width)
{
	int	len;

	len = ft_strlen(trimmed);
	if (len > *max_width)
		*max_width = len;
	ft_lstadd_back(map_lines, ft_lstnew(ft_strdup(trimmed)));
	free(trimmed);
}

map_utils.c:

#include "cub3d.h"

int	parse_texture_line(char *trimmed, t_data *data)
{
	if (!ft_strncmp(trimmed, "NO", 2) && ft_isspace(trimmed[2]))
		return (parse_texture(trimmed, data, "NO"));
	else if (!ft_strncmp(trimmed, "SO", 2) && ft_isspace(trimmed[2]))
		return (parse_texture(trimmed, data, "SO"));
	else if (!ft_strncmp(trimmed, "WE", 2) && ft_isspace(trimmed[2]))
		return (parse_texture(trimmed, data, "WE"));
	else if (!ft_strncmp(trimmed, "EA", 2) && ft_isspace(trimmed[2]))
		return (parse_texture(trimmed, data, "EA"));
	return (0);
}

int	handle_non_map_line(char *trimmed,
	t_data *data, t_list **map_lines, int *max_width)
{
	(void)map_lines;
	(void)max_width;
	if (parse_texture_line(trimmed, data))
	{
		free(trimmed);
		return (1);
	}
	else if (parse_color_line(trimmed, data))
	{
		free(trimmed);
		return (1);
	}
	else
	{
		free(trimmed);
		return (2);
	}
}

void	handle_map_line(char *trimmed, t_list **map_lines,
		int *max_width, t_data *data)
{
	if (trimmed[0] == '\0')
		error_exit("Empty line detected inside map definition.", data);
	add_map_line(trimmed, map_lines, max_width);
}

utils.c:

#include "cub3d.h"

void	ft_free_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

int	ft_isdigit_str(char *str)
{
	while (*str)
	{
		if (!ft_isdigit(*str))
			return (0);
		str++;
	}
	return (1);
}

void	free_data(t_data *data)
{
	int	i;

	if (!data)
		return ;
	if (data->north)
		free(data->north);
	if (data->south)
		free(data->south);
	if (data->east)
		free(data->east);
	if (data->west)
		free(data->west);
	if (data->map)
	{
		i = 0;
		while (data->map[i])
			free(data->map[i++]);
		free(data->map);
	}
	free(data);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	while (*s1 && *s2 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	return (*(unsigned char *)s1 - *(unsigned char *)s2);
}

char	*trim_and_free_line(char *line)
{
	char	*trimmed;

	trimmed = ft_strtrim(line, " \t\n");
	free(line);
	return (trimmed);
}

#include "cub3d.h"

int	ft_isspace(int c)
{
	return (c == ' ' || c == '\t' || c == '\n'
		|| c == '\v' || c == '\f' || c == '\r');
}

void	report_texture_errors(t_game *game)
{
	fprintf(stderr, "Error: Failed to load one or more textures:\n");
	if (!game->mlx->textures[0])
		fprintf(stderr, "- North texture: %s\n", game->data->north);
	if (!game->mlx->textures[1])
		fprintf(stderr, "- South texture: %s\n", game->data->south);
	if (!game->mlx->textures[2])
		fprintf(stderr, "- East texture: %s\n", game->data->east);
	if (!game->mlx->textures[3])
		fprintf(stderr, "- West texture: %s\n", game->data->west);
	if (!game->mlx->textures[4])
		fprintf(stderr, "- Door texture: textures/door.xpm\n");
	error_exit("Texture loading failed!", game->data);
}

void	setup_orientation(t_mlx_data *mlx, char dir)
{
	if (dir == 'N')
		set_orientation(mlx, (t_orientation){0, -1, 0.66, 0});
	else if (dir == 'S')
		set_orientation(mlx, (t_orientation){0, 1, -0.66, 0});
	else if (dir == 'E')
		set_orientation(mlx, (t_orientation){1, 0, 0, 0.66});
	else if (dir == 'W')
		set_orientation(mlx, (t_orientation){-1, 0, 0, -0.66});
}

void	free_textures(t_mlx_data *mlx)
{
	int	i;

	if (!mlx || !mlx->mlx)
		return ;
	i = 0;
	while (i < 5)
	{
		if (mlx->textures[i] && mlx->textures[i]->img)
		{
			mlx_destroy_image(mlx->mlx, mlx->textures[i]->img);
			free(mlx->textures[i]);
			mlx->textures[i] = NULL;
		}
		i++;
	}
	i = 0;
	while (i < FIREBALL_FRAMES && mlx->fire_tex[i] && mlx->fire_tex[i]->img)
	{
		mlx_destroy_image(mlx->mlx, mlx->fire_tex[i]->img);
		free(mlx->fire_tex[i]);
		mlx->fire_tex[i] = NULL;
		i++;
	}
}
