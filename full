header

#ifndef CUB3D_H
# define CUB3D_H

# include "libft.h"
# include <stdio.h>
# include <fcntl.h>
# include <string.h>
# include <unistd.h>
# include <stdlib.h>
# include <mlx.h>
# include <math.h>

# define MAP_CHARS " 01NSEW"
# define PLAYER_CHARS "NSEW"
# define ESC_KEY 65307
# define W_KEY 119
# define A_KEY 97
# define S_KEY 115
# define D_KEY 100
# define LEFT_KEY 65361
# define RIGHT_KEY 65363
# define MOVE_SPEED 0.1
# define ROTATION_SPEED 0.05

typedef struct s_keys
{
	int	w;
	int	a;
	int	s;
	int	d;
	int	left;
	int	right;
	int	esc;
}	t_keys;

typedef struct s_game
{
	t_data	*data;
	t_keys	keys;
}	t_game;

typedef struct mlx_data
{
	void	*mlx;
	void	*win;
	void	*img;
	int		bpp;
	int		line_size;
	int		endian;
	char	*img_addr;
	t_data	*data;
	t_keys	keys;
	double	pos_x;
	double	pos_y;
	double	dir_x;
	double	dir_y;
	double	plane_x;
	double	plane_y;
}	t_mlx_data;

typedef struct s_data
{
	char	*north;
	char	*south;
	char	*east;
	char	*west;
	char	**map;
	char	player_direction;
	int		floor;
	int		ceiling;
	int		map_width;
	int		map_height;
	int		player_x;
	int		player_y;
}	t_data;

typedef struct s_parse_ctx
{
	t_data	*data;
	t_list	**map_lines;
	int		*max_width;
}	t_parse_ctx;

// CONTROLLER
void	try_movement(t_mlx_data *mlx, double dx, double dy);
int		is_walkable(t_data *data, double x, double y);

// ERROR HANDLER
int		error_exit(char *msg, t_data *data);

// FLOOD FILL
char	**dup_map(t_data *data);
void	flood_fill(t_data *data, char **map, int x, int y);

// MAIN

// MAP VALIDATOR

int		is_invalid_tile(t_data *data, int x, int y);
void	validate_map_char_at(t_data *data, int x, int y, int *player_count);
void	validate_map_chars(t_data *data);
void	validate_map_with_flood_fill(t_data *data);

// MOVEMENT
int		key_press(int keycode, t_game *game);
int		key_release(int keycode, t_game *game);
void	update_player_position(t_game *game);

// CUB PARSER
void	parse_lines_loop(int fd, t_data *data,
			t_list **map_lines, int *max_width);
void	check_required_elements(t_data *data);
t_data	*parse_cub_file(char *filename);

// PARSER
int		parse_rgb_component(char *part, int *value);
int		parse_rgb(char **parts, int *rgb);
int		parse_color(char *line, t_data *data, char id);
int		parse_texture(char *line, t_data *data, const char *id);
int		parse_color_line(char *trimmed, t_data *data);

// MAP PROCESSING UTILS
void	copy_map_lines(t_data *data, t_list *map_lines, int max_width);
void	process_trimmed_line(char *trimmed, int *map_started, t_parse_ctx *ctx);
void	allocate_and_fill_map(t_data *data, t_list *map_lines, int max_width);
void	add_map_line(char *trimmed, t_list **map_lines, int *max_width);

// MAP UTILS
int		parse_texture_line(char *trimmed, t_data *data);
int		handle_non_map_line(char *trimmed,
			t_data *data, t_list **map_lines, int *max_width);
void	handle_map_line(char *trimmed, t_list **map_lines, int *max_width);

// UTILS
void	ft_free_array(char **array);
int		ft_isdigit_str(char *str);
void	free_data(t_data *data);
int		ft_strcmp(const char *s1, const char *s2);
char	*trim_and_free_line(char *line);
int		ft_isspace(int c);

#endif

controller.c

#include "cub3d.h"

int	is_walkable(t_data *data, double x, double y)
{
	int	map_x;
	int	map_y;

	map_x = (int)x;
	map_y = (int)y;
	if (map_y < 0 || map_y >= data->map_height || map_x < 0
		|| map_x >= data->map_width)
		return (0);
	return (data->map[map_y][map_x] != '1');
}

void	try_movement(t_mlx_data *mlx, double dx, double dy)
{
	double	new_x;
	double	new_y;

	new_x = mlx->pos_x + dx;
	new_y = mlx->pos_y + dy;
	if (is_walkable(mlx->data, new_x, new_y))
		mlx->pos_x = new_x;
	if (is_walkable(mlx->data, new_x, new_y +1))
		mlx->pos_y = new_y;
}

error_handler.c

#include "cub3d.h"

int	error_exit(char *msg, t_data *data)
{
	if (data)
		free_data(data);
	ft_putstr_fd("Error\n", 2);
	ft_putstr_fd(msg, 2);
	ft_putstr_fd("\n", 2);
	exit(1);
}

events.c

#include "cub3d.h"

int	close_event(t_mlx_data *mlx)
{
	if (mlx->img)
		mlx_destroy_image(mlx->mlx, mlx->img);
	if (mlx->win)
		mlx_destroy_window(mlx->mlx, mlx->win);
	mlx_destroy_display(mlx->mlx);
	free(mlx->mlx);
	free(mlx);
	exit(0);
	return (0);
}

void	events(t_mlx_data *mlx)
{
	mlx_hook(mlx->win, 2, 1L << 0, key_press, mlx); // Key down
	mlx_hook(mlx->win, 3, 1L << 1, key_release, mlx); // Key up
	mlx_hook(mlx->win, 17, 0, close_event, mlx); // Close
}

flood_fill.c

#include "cub3d.h"

void	flood_fill(t_data *data, char **map, int x, int y)
{
	if (y < 0 || y >= data->map_height
		|| x < 0 || x >= (int)ft_strlen(map[y]))
		error_exit("Map leak: flood escaped the map!", data);
	if (map[y][x] == '1' || map[y][x] == 'F')
		return ;
	if (map[y][x] == ' ')
		error_exit("Map leak: flood hit open space!", data);
	if (!ft_strchr("0NSEW", map[y][x]))
		return ;

	map[y][x] = 'F';
	flood_fill(data, map, x + 1, y);
	flood_fill(data, map, x - 1, y);
	flood_fill(data, map, x, y + 1);
	flood_fill(data, map, x, y - 1);
}

char	**dup_map(t_data *data)
{
	char	**copy;
	int		i;

	copy = ft_calloc(data->map_height + 1, sizeof(char *));
	i = 0;
	if (!copy)
		error_exit("Memory failed during flood fill", data);
	while (i < data->map_height)
	{
		copy[i] = ft_strdup(data->map[i]);
		i++;
	}
	return (copy);
}

